OTU_OTU_pvalue = 0.001,
OTU_OTU_rvalue = 0.6,
OTU_Phenotype_pvalue = 0.6,
definePhenotype="Marketable",
defineTreatment="Maxifort",
coloredby="Phylum",
PhenoNodecolor="yellow",
PhenoNodesize=20,
PhenoNodelabel="Yield",
nodesize=10,
Pheno2OTUedgecolor = "black",
netlayout=layout.fruchterman.reingold){
###
odata = t(otu_table(physeqobj))
mdata = sample_data(physeqobj)
tdata = taxdata
#tdata = data.frame(tax_table(physeqobj)) # is too slow
###
####### check the validity of parater, flag if not
possible_tax <- c("Kingdom","Phylum","Class","Order","Family","Genus","Species")
if (coloredby %in% possible_tax) {
# create a color palltet using coloredby
# number of unique color needed
mod.vec <- tdata %>%
pull(coloredby) %>%
as.character()
n <- length(unique(mod.vec))
mod.num <- as.numeric(as.factor(mod.vec))
ucolors <- distinctColorPalette(n)
tdata["color"] <- sapply(mod.num, function(j) ucolors[j])
} else {
cat(" Provided coloredby: ", coloredby,"\n")
stop("Please provide correct coloredby paramter. Available options are: Kingdom,
Phylum, Class, Order, Family, Genus, Species")
}
######
p.yes <- pdata < OTU_OTU_pvalue
p.yes.r <- cordata * p.yes
p.yes.r <- abs(p.yes.r) > OTU_OTU_rvalue
p.yes.rr <- p.yes.r * sparcc.cor
adjm <- as.matrix(p.yes.rr)
adjm <- as.matrix(adjm)
## Select only the taxa for the filtered OTUs by using rownames of otu.pval
sel.tax <- tdata[rownames(adjm), , drop = FALSE]
all.equal(rownames(sel.tax), rownames(adjm))
net.grph = graph.adjacency(adjm, mode = "undirected", weighted = TRUE, diag = FALSE)
edgew <- E(net.grph)$weight
##
V(net.grph)$Kingdom <- as.character(sel.tax$Kingdom)
V(net.grph)$Phylum <- as.character(sel.tax$Phylum)
V(net.grph)$Class <- as.character(sel.tax$Class)
V(net.grph)$Order <- as.character(sel.tax$Order)
V(net.grph)$Family <- as.character(sel.tax$Family)
V(net.grph)$Genus <- as.character(sel.tax$Genus)
V(net.grph)$Species <- as.character(sel.tax$Species)
V(net.grph)$color <- tdata$color
x = mdata %>% pull(definePhenotype)  ## generalize to metadata
if (model == "lm"){
bb =  model.linear(x, odata)
}
bb$relation <- rnorm(dim(bb)[1], mean = 0.2, sd = 0.2)
from <- rep(defineTreatment,dim(bb)[1])  ### how to get sel.rootstock
df <-data.frame(FROM = from, TO=bb$otu, relation=bb$relation, pv =bb$pvalue)
df.g <- graph.data.frame(d = df, directed = FALSE)
E(df.g)$weight <- bb$relation
#plot(df.g)
E(df.g)$color = Pheno2OTUedgecolor
E(df.g)$lty <- ifelse(E(df.g)$weight < 0, 2 ,1) # if negative dotted
###
net.grph
E(net.grph)$color = ifelse(E(net.grph)$weight < 0,"red","blue") # if negative red
E(net.grph)$lty <- 1
##c combined two graphs
net.two <- graph.union(df.g, net.grph)
# Edge color
color.g1 <- E(net.two)$color_1 %>% .[!is.na(.)]
color.g2 <- E(net.two)$color_2 %>% .[!is.na(.)]
combined_color <- c(color.g2,color.g1)
E(net.two)$color <- combined_color
# Edge link type
linktype.g1 <- E(net.two)$lty_1 %>% .[!is.na(.)]
linktype.g2 <- E(net.two)$lty_2 %>% .[!is.na(.)]
combined_linktype <- c(linktype.g2,linktype.g1)
E(net.two)$lty<- combined_linktype
bad.vs3 <- V(net.two)[degree(net.two) == 0 | degree(net.two) == 1 ]
# # remove isolated nodes
net.two <- delete.vertices(net.two, bad.vs3)
##
V(net.two)$color[1] <- PhenoNodecolor
V(net.two)$size <- rep(nodesize,vcount(net.two))
V(net.two)$size[1] <- PhenoNodesize
V(net.two)$nName <- V(net.two)$Genus ## can be passed as option
V(net.two)$nName[1] <- defineTreatment
V(net.two)$vertex.label.size = rep(0.5,vcount(net.two))
V(net.two)$vertex.label.size[1] <- 1
V(net.two)$vertex.label_type = rep(1,vcount(net.two))
V(net.two)$vertex.label_type[1] <- 2
V(net.two)$nName[1] <- PhenoNodelabel
par(mar = c(0, 0, 0, 0))
plot(net.two,
vertex.frame.color="black",
edge.curved=F,
layout=netlayout,
vertex.label=V(net.two)$nName,
vertex.label.color="black",
vertex.label.family="Times New Roman",
vertex.label.font=V(net.two)$vertex.label_type,
vertex.label.cex=V(net.two)$vertex.label.size)
# legend_nodes <- unique(V(net.two)$Phylum)
legend_nodes <- unique(get.vertex.attribute(net.two)[coloredby][[1]])
legend_nodes[1] <-  PhenoNodelabel
legend(x=1.1, y=1.1,legend_nodes, pch=21, pt.bg=unique( V(net.two)$color), pt.cex=2, cex=.8, bty="n", ncol=1)
net.two
}
PhONA <- function(physeqobj = physeq,
cordata = sparcc.cor,
pdata = sparcc.pval,
model = "lm",
OTU_OTU_pvalue = 0.001,
OTU_OTU_rvalue = 0.6,
OTU_Phenotype_pvalue = 0.6,
definePhenotype="Marketable",
defineTreatment="Maxifort",
coloredby="Phylum",
PhenoNodecolor="yellow",
PhenoNodesize=20,
PhenoNodelabel="Yield",
nodesize=10,
Pheno2OTUedgecolor = "black",
netlayout=layout.fruchterman.reingold){
###
odata = t(otu_table(physeqobj))
mdata = sample_data(physeqobj)
tdata = taxdata
#tdata = data.frame(tax_table(physeqobj)) # is too slow
###
####### check the validity of parater, flag if not
possible_tax <- c("Kingdom","Phylum","Class","Order","Family","Genus","Species")
if (coloredby %in% possible_tax) {
# create a color palltet using coloredby
# number of unique color needed
mod.vec <- tdata %>%
pull(coloredby) %>%
as.character()
n <- length(unique(mod.vec))
mod.num <- as.numeric(as.factor(mod.vec))
ucolors <- distinctColorPalette(n)
tdata["color"] <- sapply(mod.num, function(j) ucolors[j])
} else {
cat(" Provided coloredby: ", coloredby,"\n")
stop("Please provide correct coloredby paramter. Available options are: Kingdom,
Phylum, Class, Order, Family, Genus, Species")
}
######
p.yes <- pdata < OTU_OTU_pvalue
p.yes.r <- cordata * p.yes
p.yes.r <- abs(p.yes.r) > OTU_OTU_rvalue
p.yes.rr <- p.yes.r * sparcc.cor
adjm <- as.matrix(p.yes.rr)
adjm <- as.matrix(adjm)
## Select only the taxa for the filtered OTUs by using rownames of otu.pval
sel.tax <- tdata[rownames(adjm), , drop = FALSE]
all.equal(rownames(sel.tax), rownames(adjm))
net.grph = graph.adjacency(adjm, mode = "undirected", weighted = TRUE, diag = FALSE)
edgew <- E(net.grph)$weight
##
V(net.grph)$Kingdom <- as.character(sel.tax$Kingdom)
V(net.grph)$Phylum <- as.character(sel.tax$Phylum)
V(net.grph)$Class <- as.character(sel.tax$Class)
V(net.grph)$Order <- as.character(sel.tax$Order)
V(net.grph)$Family <- as.character(sel.tax$Family)
V(net.grph)$Genus <- as.character(sel.tax$Genus)
V(net.grph)$Species <- as.character(sel.tax$Species)
V(net.grph)$color <- tdata$color
x = mdata %>% pull(definePhenotype)  ## generalize to metadata
if (model == "lm"){
bb =  model.linear(x, odata)
}
bb$relation <- rnorm(dim(bb)[1], mean = 0.2, sd = 0.2)
from <- rep(defineTreatment,dim(bb)[1])  ### how to get sel.rootstock
df <-data.frame(FROM = from, TO=bb$otu, relation=bb$relation, pv =bb$pvalue)
df.g <- graph.data.frame(d = df, directed = FALSE)
E(df.g)$weight <- bb$relation
#plot(df.g)
E(df.g)$color = Pheno2OTUedgecolor
E(df.g)$lty <- ifelse(E(df.g)$weight < 0, 2 ,1) # if negative dotted
###
net.grph
E(net.grph)$color = ifelse(E(net.grph)$weight < 0,"red","blue") # if negative red
E(net.grph)$lty <- 1
##c combined two graphs
net.two <- graph.union(df.g, net.grph)
# Edge color
color.g1 <- E(net.two)$color_1 %>% .[!is.na(.)]
color.g2 <- E(net.two)$color_2 %>% .[!is.na(.)]
combined_color <- c(color.g2,color.g1)
E(net.two)$color <- combined_color
# Edge link type
linktype.g1 <- E(net.two)$lty_1 %>% .[!is.na(.)]
linktype.g2 <- E(net.two)$lty_2 %>% .[!is.na(.)]
combined_linktype <- c(linktype.g2,linktype.g1)
E(net.two)$lty<- combined_linktype
bad.vs3 <- V(net.two)[degree(net.two) == 0 | degree(net.two) == 1 ]
# # remove isolated nodes
net.two <- delete.vertices(net.two, bad.vs3)
##
V(net.two)$color[1] <- PhenoNodecolor
V(net.two)$size <- rep(nodesize,vcount(net.two))
V(net.two)$size[1] <- PhenoNodesize
V(net.two)$nName <- V(net.two)$Genus ## can be passed as option
V(net.two)$nName[1] <- defineTreatment
V(net.two)$vertex.label.size = rep(0.5,vcount(net.two))
V(net.two)$vertex.label.size[1] <- 1
V(net.two)$vertex.label_type = rep(1,vcount(net.two))
V(net.two)$vertex.label_type[1] <- 2
V(net.two)$nName[1] <- PhenoNodelabel
par(mar = c(0, 0, 0, 0))
plot(net.two,
vertex.frame.color="black",
edge.curved=F,
layout=netlayout,
vertex.label=V(net.two)$nName,
vertex.label.color="black",
vertex.label.family="Times New Roman",
vertex.label.font=V(net.two)$vertex.label_type,
vertex.label.cex=V(net.two)$vertex.label.size)
# legend_nodes <- unique(V(net.two)$Phylum)
legend_nodes <- unique(get.vertex.attribute(net.two)[coloredby][[1]])
legend_nodes[1] <-  PhenoNodelabel
legend(x=1.1, y=1.1,legend_nodes, pch=21, pt.bg=unique( V(net.two)$color), pt.cex=2, cex=.8, bty="n", ncol=1)
net.two
}
PhONA(coloredby="Phylum",
PhenoNodecolor="Red",
PhenoNodesize=20,
nodesize=10,
PhenoNodelabel="Yield",
Pheno2OTUedgecolor = "black",
netlayout=layout.fruchterman.reingold)
ls
getwd()
devtools::document()
library(PhONA)
help(PhONA)
devtools::document()
devtools::document()
library(phyloseq)
devtools::document()
library(phyloseq)
devtools::document()
library(phyloseq)
devtools::document()
library(tidyverse)
devtools::document()
devtools::document()
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
model.linear <- function(x, odata){
mat <- list()
for (i in 1:ncol(odata)){
y <- odata[, i]
which_otu <- colnames(odata)[i]
mod <- lm(x ~ y)
sum_mod <- summary.lm(mod)
pv <- round(sum_mod$coefficients[8], 4)
r2 <- round(sum_mod$r.squared,4)
mat[[i]] <- list(num = i, otu = which_otu, pvalue = pv, relation = r2)}
dd <- data.frame(matrix(unlist(mat), nrow=length(mat), byrow=T))
colnames(dd) = names(mat[[1]])
dd["Treatment"] <- defineTreatment
return(dd)
}
View(model.linear)
rm(model.linear())
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
document()
library("devtools")
library("roxygen2")
devtools::document()
devtools::document()
devtools::document()
library(devtools)
document()
build()
install()
library(PhONA)
devtools::document()
pwd
getwd()
source("R/model.linear.R")
devtools::document()
defineTreatment
devtools::document()
source("R/model.linear.R")
bb =  model.linear(x, odata)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(PhONA)
PhONA()
help(PhONA)
help(PhONA)
library(PhONA)
help(PhONA)
??PhONA
library(PhONA)
PhONA()
PhONA
help(PhONA)
help(PhONA)
??PhONA
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(PhONA)
help(PhoNA)
PhONA()
help(PhONA)
??PhONA
help(PhONA)
PhONA()
model.linear
PhONA()
devtools::document()
install("PhONA")
install.packages("PhONA")
install.packages("PhONA")
devtools::document()
devtools::document()
help(model.linear)
devtools::document()
devtools::document()
help(model.linear)
help(PhONA)
PhONA::PhONA()
help(PhONA::PhONA())
help(PhONA)
devtools::document()
help(model.linear)
devtools::document()
devtools::document()
devtools::load_all()
devtools::load_all()
devtools::document()
help(PhONA)
devtools::document()
library(PhONA)
help(PhONA)
help(.model_linear)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
help(PhONA)
devtools::document()
devtools::document()
help(model.linear)
devtools::document()
library(PhONA)
help(PhONA)
help(model.linear)
otudata <- read.csv("data/OTU.csv", header = TRUE, row.names = 1)
taxdata <- read.csv("data/Taxonomy.csv", header = TRUE, row.names = 1)
metadata <- read.csv("data/Metadata.csv", header = TRUE, row.names = 1)
# create a phyloseq object~ can combine count, metadata, taxonomy, and phylogentic tree.
otu.mat = otu_table(t(otudata), taxa_are_rows = TRUE)
tax.mat <- tax_table(as.matrix(taxdata))
sample.mat <- sample_data(metadata)
physeq = phyloseq(otu.mat, tax.mat, sample.mat)
###### get OTU- OTU matrix ##
sparcc.cor <- read.delim("data/SparCC_out/cor_sparcc.out", sep = "\t", header = T, row.names = 1)
sparcc.pval <- read.delim("data/SparCC_out/pvals.txt", sep = "\t", header = T, row.names = 1)
PhONA()
devtools::document()
devtools::document()
library(PhONA)
help(PhONA)
help(model.linear)
otudata <- read.csv("data/OTU.csv", header = TRUE, row.names = 1)
taxdata <- read.csv("data/Taxonomy.csv", header = TRUE, row.names = 1)
metadata <- read.csv("data/Metadata.csv", header = TRUE, row.names = 1)
# create a phyloseq object~ can combine count, metadata, taxonomy, and phylogentic tree.
otu.mat = otu_table(t(otudata), taxa_are_rows = TRUE)
tax.mat <- tax_table(as.matrix(taxdata))
sample.mat <- sample_data(metadata)
physeq = phyloseq(otu.mat, tax.mat, sample.mat)
###### get OTU- OTU matrix ##
sparcc.cor <- read.delim("data/SparCC_out/cor_sparcc.out", sep = "\t", header = T, row.names = 1)
sparcc.pval <- read.delim("data/SparCC_out/pvals.txt", sep = "\t", header = T, row.names = 1)
PhONA()
devtools::document()
devtools::document()
library(PhONA)
help(PhONA)
help(model.linear)
PhONA()
PhONA(coloredby="Phylum",
PhenoNodecolor="Red",
PhenoNodesize=20,
nodesize=10,
PhenoNodelabel="Yield",
Pheno2OTUedgecolor = "black",
netlayout=layout.fruchterman.reingold)
devtools::document()
library(PhONA)
help(PhONA)
help(model.linear)
system.file("extdata", "Metadata.csv", package = "PhONA")
phyloseq()
physeq
otudata <- read.csv("data/OTU.csv", header = TRUE, row.names = 1)
taxdata <- read.csv("data/Taxonomy.csv", header = TRUE, row.names = 1)
devtools::document()
library(PhONA)
help(PhONA)
help(model.linear)
otudata <- read.csv("data/OTU.csv", header = TRUE, row.names = 1)
otudata <- read.csv("data/OTU.csv", header = TRUE, row.names = 1)
taxdata <- read.csv("data/Taxonomy.csv", header = TRUE, row.names = 1)
metadata <- read.csv("data/Metadata.csv", header = TRUE, row.names = 1)
# create a phyloseq object~ can combine count, metadata, taxonomy, and phylogentic tree.
otu.mat = otu_table(t(otudata), taxa_are_rows = TRUE)
tax.mat <- tax_table(as.matrix(taxdata))
sample.mat <- sample_data(metadata)
physeq = phyloseq(otu.mat, tax.mat, sample.mat)
physeq
saveRDS(physeq, "physeqobject.rds")
phy <- system.file("extdata", "physeqobject.rds", package = "PhONA")
phy
data(phy)
phy <- system.file("extdata", "physeqobject.rds", package = "PhONA")
data(phy)
phy
dat <- readRDS(phy)
dat
phy <- readRDS(system.file("extdata", "physeqobject.rds", package = "PhONA"))
phy
sparcc.cor <- read.csv(system.file("extdata", "cor_sparcc.out", package = "PhONA"), header = TRUE, row.names = 1)
sparcc.cor
phyobj <- readRDS(system.file("extdata", "physeqobject.rds", package = "PhONA"))
sparcc.cor <- read.delim(system.file("extdata", "cor_sparcc.out", package = "PhONA"), sep = "\t", header = T, row.names = 1)
sparcc.pval <- read.delim(system.file("extdata", "pvals.txt", package = "PhONA"), sep = "\t", header = T, row.names = 1)
sparcc.cor
dim(sparcc.cor)
dim(sparcc.pval )
library(PhONA)
devtools::document()
devtools::document()
library(PhONA)
help(PhONA)
help(model.linear)
###### Load the data
phyobj <- readRDS(system.file("extdata", "physeqobject.rds", package = "PhONA"))
sparcc.cor <- read.delim(system.file("extdata", "cor_sparcc.out", package = "PhONA"), sep = "\t", header = T, row.names = 1)
sparcc.pval <- read.delim(system.file("extdata", "pvals.txt", package = "PhONA"), sep = "\t", header = T, row.names = 1)
PhONA()
help(PhONA)
PhONA(
physeqobj = phyobj,
cordata = sparcc.cor,
pdata = sparcc.pval,
model = "lm",
OTU_OTU_pvalue = 0.001,
OTU_OTU_rvalue = 0.6,
OTU_Phenotype_pvalue = 0.6,
definePhenotype = "Marketable",
defineTreatment = "Maxifort",
coloredby = "Phylum",
PhenoNodecolor = "yellow",
PhenoNodesize = 20,
PhenoNodelabel = "Yield",
nodesize = 10,
Pheno2OTUedgecolor = "black",
netlayout = layout.fruchterman.reingold
)
devtools::use_vignette("PhONA")
devtools::document()
devtools::document()
library(PhONA)
library(PhONA)
devtools::document()
traceback()
devtools::document()
library(PhONA)
help(PhONA)
help(model.linear)
devtools::document()
library(PhONA)
legend("bottomleft",
install.packages("tufte")
library(tufte)
install_github("kbroman/broman")
library(devtools)
install_github("ravinpoudel/PhONA")
